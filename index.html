<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BODMAS Engine - Smart Associativity</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: #ffffff;
            color: #1a1a1a;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* --- Shared Node Styles --- */
        .node {
            transition: all 0.2s ease;
            background: white;
            user-select: none;
        }

        .node-operator.can-evaluate {
            cursor: pointer;
            border-color: #2563eb;
            color: #2563eb;
            background-color: #eff6ff;
            font-weight: 700;
        }

        .node-operator.can-evaluate:hover {
            background-color: #2563eb;
            color: #ffffff;
            transform: translateY(-2px);
            box-shadow: 0 4px 6px -1px rgba(37, 99, 235, 0.2);
        }

        .frac {
            display: inline-flex;
            flex-direction: column;
            vertical-align: middle;
            text-align: center;
            line-height: 1.1;
            font-size: 0.9em;
        }
        .frac span.top { border-bottom: 1px solid currentColor; padding: 0 2px; }

        /* --- Viewport & Canvas --- */
        .tree-viewport { overflow: auto; }

        #treeContainer {
            min-width: 2500px; 
            min-height: 2000px;
            display: grid;
            place-items: center;
            padding: 400px;
        }

        /* --- Tree View --- */
        .tree-view-active #treeContainer {
            background-image: radial-gradient(#e5e7eb 1px, transparent 1px);
            background-size: 30px 30px;
        }

        .connector {
            stroke: #94a3b8;
            stroke-width: 1.5;
            fill: none;
            transition: d 0.3s ease;
        }

        /* --- Expression View --- */
        .expression-view-active #treeViewport {
            display: block; 
            background-color: #f8fafc;
        }
        .expression-view-active #treeContainer { background: none; }
        .expression-view-active #treeContent {
            display: flex;
            flex-wrap: nowrap; 
            gap: 12px;
            align-items: center;
            justify-content: center;
        }
        .expression-bracket {
            font-size: 2.5rem;
            color: #94a3b8;
            font-weight: 300;
        }
    </style>
</head>
<body>

    <header class="fixed top-0 left-0 right-0 p-4 border-b bg-white/80 backdrop-blur-md z-50 flex justify-between items-center">
        <div class="flex items-center gap-4">
            <h1 class="text-sm font-bold tracking-tight text-gray-500 uppercase hidden md:block">Arithmetic Engine</h1>
            <div class="bg-gray-100 p-1 rounded-lg flex text-xs font-medium">
                <button id="viewTreeBtn" class="px-3 py-1.5 rounded-md shadow-sm bg-white text-gray-900 transition-all">Tree</button>
                <button id="viewExprBtn" class="px-3 py-1.5 rounded-md text-gray-500 hover:text-gray-900 transition-all">Expression</button>
            </div>
        </div>
        
        <div class="flex items-center gap-2">
            <button id="undoBtn" disabled class="flex items-center gap-2 border border-gray-200 bg-white text-gray-700 px-4 py-2 rounded text-sm font-medium hover:bg-gray-50 transition-all disabled:opacity-50 disabled:cursor-not-allowed">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 7v6h6"/><path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/></svg>
                Undo
            </button>
            <button id="regenerateBtn" class="bg-gray-900 text-white px-4 py-2 rounded text-sm font-medium hover:bg-gray-700 transition-colors">
                New Question
            </button>
        </div>
    </header>

    <main class="flex-grow relative overflow-hidden flex flex-col pt-16">
        <div id="treeViewport" class="tree-viewport flex-grow overflow-auto relative w-full cursor-grab active:cursor-grabbing">
            <div id="treeContainer" class="relative">
                <svg id="svgConnectors" class="absolute inset-0 w-full h-full pointer-events-none"></svg>
                <div id="treeContent" class="relative z-10"></div>
            </div>
        </div>
    </main>

    <footer class="fixed bottom-0 left-0 right-0 p-6 flex justify-center z-50 pointer-events-none">
        <div class="pointer-events-auto bg-white border border-gray-200 p-4 rounded-lg shadow-sm max-w-2xl w-full text-center">
            <div class="text-[10px] font-bold uppercase text-gray-400 mb-1">Current String</div>
            <div id="expressionText" class="text-lg font-medium text-gray-700 font-mono"></div>
        </div>
    </footer>

    <script>
        // --- Math Logic ---
        const gcd = (a, b) => { a = Math.abs(a); b = Math.abs(b); while (b) { a %= b; [a, b] = [b, a]; } return a; };
        const simplify = (n, d) => {
            if (d === 0) return { n, d };
            const common = gcd(n, d);
            let finalN = n / common;
            let finalD = d / common;
            if (finalD < 0) { finalN = -finalN; finalD = -finalD; }
            return { n: finalN, d: finalD };
        };

        const fracOps = {
            '+': (a, b) => simplify(a.n * b.d + b.n * a.d, a.d * b.d),
            '-': (a, b) => simplify(a.n * b.d - b.n * a.d, a.d * b.d),
            '×': (a, b) => simplify(a.n * b.n, a.d * b.d),
            '÷': (a, b) => simplify(a.n * b.d, a.d * b.n)
        };

        // Standard JS Math for the "Fake Tree" evaluation
        const simpleOps = {
            '+': (a, b) => a + b,
            '-': (a, b) => a - b,
            '×': (a, b) => a * b,
            '÷': (a, b) => b === 0 ? Infinity : a / b
        };

        // --- State ---
        let treeData = null;
        let historyStack = [];
        let currentView = 'tree'; 

        function generateRandomTree(depth = 0, maxDepth = 3) {
            const id = 'node-' + Math.random().toString(36).substr(2, 9);
            const isLeaf = depth >= maxDepth || (depth > 0 && Math.random() > 0.4);
            if (isLeaf) {
                return { id, type: 'operand', value: { n: Math.floor(Math.random() * 12) + 1, d: 1 } };
            } else {
                const symbols = Object.keys(fracOps);
                const symbol = symbols[Math.floor(Math.random() * symbols.length)];
                return { id, type: 'operator', value: symbol, left: generateRandomTree(depth + 1, maxDepth), right: generateRandomTree(depth + 1, maxDepth) };
            }
        }

        // --- Core: Smart Evaluation Logic ---

        // 1. Create a map of random values for every Leaf Node ID to use in simulation
        function createRandomValueMap(node, map = {}) {
            if (node.type === 'operand') {
                map[node.id] = Math.random() * 100; // Use floats to avoid accidental integer division matches
            } else {
                createRandomValueMap(node.left, map);
                createRandomValueMap(node.right, map);
            }
            return map;
        }

        // 2. Evaluate a tree using the random map instead of real fractions
        function evaluateFakeTree(node, valueMap) {
            if (node.type === 'operand') return valueMap[node.id];
            const l = evaluateFakeTree(node.left, valueMap);
            const r = evaluateFakeTree(node.right, valueMap);
            return simpleOps[node.value](l, r);
        }

        // 3. Deep copy helper
        function deepClone(obj) { return JSON.parse(JSON.stringify(obj)); }

        // 4. Try to rotate/evaluate a specific node
        // Returns the NEW tree if valid, or null if invalid
        function trySmartEvaluate(fullTree, targetNodeId) {
            // Helper to traverse and find/replace the target node
            // This is complex: we might need to modify the PARENT of the target node,
            // or the Node itself might become the child of a rotated parent.
            
            // Strategy: We will try 3 transformations on the specific node:
            // A. Standard Evaluate (Left and Right are leaves)
            // B. Rotate Left (Node is Op1, Right child is Op2 -> become Op2(Op1(..), ..))
            // C. Rotate Right (Node is Op1, Left child is Op2 -> become Op2(.., Op1(..)))
            
            // For B and C, we generate a candidate tree structure, 
            // run the Random Number check, and if Equivalent, we return the candidate.

            // First, generate the random map for the CURRENT full tree.
            const valueMap = createRandomValueMap(fullTree);
            const originalResult = evaluateFakeTree(fullTree, valueMap);

            // We need a function that traverses, finds the target, and returns a modified tree
            const transform = (node) => {
                if (node.id === targetNodeId) {
                    
                    // Case A: Standard
                    if (node.left.type === 'operand' && node.right.type === 'operand') {
                        const res = fracOps[node.value](node.left.value, node.right.value);
                        return { id: 'node-' + Math.random().toString(36).substr(2, 9), type: 'operand', value: res };
                    }

                    // Case B: Right Child is Operator ( e.g. A + (B + C) -> try (A + B) )
                    if (node.right.type === 'operator' && node.left.type === 'operand') {
                        // We want to transform: Op1(A, Op2(B, C)) -> Op2( Op1(A, B), C )
                        // But wait, we want to EVALUATE Op1(A, B) immediately.
                        // So the structure becomes: Op2( Evaluated_Result, C )
                        
                        const op1 = node.value;
                        const A = node.left.value;
                        const B = node.right.left.value; // "Steal" the left child of the right operator

                        // Construct the "Hypothetical" result of the operation
                        const resVal = fracOps[op1](A, B);
                        const resNode = { id: 'temp-res', type: 'operand', value: resVal };

                        // Construct Candidate Node: Op2( Result, C )
                        const candidateNode = {
                            ...node.right, // Takes ID and Value of Op2
                            left: resNode,
                            right: node.right.right
                        };
                        return { candidate: candidateNode, type: 'smart' };
                    }

                    // Case C: Left Child is Operator ( e.g. (A + B) + C -> try B + C )
                    if (node.left.type === 'operator' && node.right.type === 'operand') {
                        // We want to transform: Op1( Op2(A, B), C ) -> Op2( A, Op1(B, C) )
                        // Evaluate Op1(B, C) immediately.
                        // Structure becomes: Op2( A, Evaluated_Result )

                        const op1 = node.value;
                        const C = node.right.value;
                        const B = node.left.right.value; // "Steal" right child of left operator

                        const resVal = fracOps[op1](B, C);
                        const resNode = { id: 'temp-res', type: 'operand', value: resVal };

                        const candidateNode = {
                            ...node.left, // Takes ID and Value of Op2
                            left: node.left.left,
                            right: resNode
                        };
                        return { candidate: candidateNode, type: 'smart' };
                    }
                }

                // Recursive Traversal
                if (node.type === 'operator') {
                    const newLeft = transform(node.left);
                    const newRight = transform(node.right);

                    // If a change happened below
                    if (newLeft !== node.left || newRight !== node.right) {
                        
                        // If one of the children returned a "Smart Candidate" wrapper
                        if (newLeft && newLeft.type === 'smart') return { ...node, left: newLeft.candidate };
                        if (newRight && newRight.type === 'smart') return { ...node, right: newRight.candidate };
                        
                        // Standard reconstruction
                        return { ...node, left: newLeft, right: newRight };
                    }
                }
                return node;
            };

            const newTree = transform(deepClone(fullTree));

            // If no transformation happened
            if (newTree === fullTree) return null;
            
            // If transformation happened, VALIDATE with Fake Tree
            // We must handle the case where 'transform' returned the wrapped candidate at the root
            let finalTreeCandidate = newTree;
            if (newTree.type === 'smart') finalTreeCandidate = newTree.candidate;

            // Note: The 'temp-res' node in candidate doesn't have an ID in the ValueMap.
            // But we already calculated the math result.
            // We need to inject the values into the map OR handle the fact that the structure changed.
            
            // Actually, simpler validation:
            // The transform function ALREADY performed the math operation using the Real Fractions.
            // We just need to know if that Math was legal.
            // So we need to build a "Test Tree" that has the ROTATED structure but NOT the evaluated values yet,
            // to check associativity.
            
            // Let's do the validation slightly differently to be robust:
            // 1. Build a "Rotated Tree" (pure structure change, no math).
            // 2. Compare Fake Results.
            // 3. If Valid, perform the math on the Real Tree.

            // RETRY Logic for robustness:
            // Just check the Math on the Specific Rotation.
            // If Op1(A, Op2(B, C)) -> Check if Fake(Op1(A, Op2(B,C))) == Fake(Op2(Op1(A,B), C))
            
            // Since we already generated the "Evaluated" tree in 'newTree', let's just 
            // check if the numeric result of the ENTIRE new tree matches the ENTIRE old tree
            // using floating point logic.
            // BUT: The new tree has collapsed nodes. We can't use the old ID map for the collapsed part.
            // This is tricky.
            
            // Alternative:
            // Trust the `fracOps` logic (it's correct math). 
            // We just need to know if the Rotation is valid.
            // (A + B) + C == A + (B + C) ? True.
            // (A - B) - C == A - (B - C) ? False.
            
            // Let's implement the specific rotation check locally at the node.
            // ID lookup is passed recursively.
            return validateAndExecute(fullTree, targetNodeId, valueMap, originalResult);
        }

        function validateAndExecute(fullTree, targetId, valueMap, originalTotal) {
            
            const traverse = (node) => {
                if (node.id === targetId) {
                    // Case A: Standard
                    if (node.left.type === 'operand' && node.right.type === 'operand') {
                        const res = fracOps[node.value](node.left.value, node.right.value);
                        return { id: 'node-' + Math.random(), type: 'operand', value: res };
                    }

                    // Case B: Right Rotation Check
                    if (node.right.type === 'operator' && node.left.type === 'operand') {
                        // Check: Op1(a, Op2(b, c)) == Op2(Op1(a, b), c)
                        const a = valueMap[node.left.id];
                        const b = valueMap[node.right.left.id];
                        const c = evaluateFakeTree(node.right.right, valueMap); // Recursive for rest of subtree
                        
                        const val1 = simpleOps[node.value](a, simpleOps[node.right.value](b, c));
                        const val2 = simpleOps[node.right.value](simpleOps[node.value](a, b), c);
                        
                        if (Math.abs(val1 - val2) < 0.0001) {
                            // Valid! Return evaluated node structure
                            const res = fracOps[node.value](node.left.value, node.right.left.value);
                            return { 
                                ...node.right, 
                                left: { id: 'new-'+Math.random(), type: 'operand', value: res }
                            };
                        }
                    }

                    // Case C: Left Rotation Check
                    if (node.left.type === 'operator' && node.right.type === 'operand') {
                        // Check: Op1(Op2(a, b), c) == Op2(a, Op1(b, c))
                        const a = evaluateFakeTree(node.left.left, valueMap);
                        const b = valueMap[node.left.right.id];
                        const c = valueMap[node.right.id];

                        const val1 = simpleOps[node.value](simpleOps[node.left.value](a, b), c);
                        const val2 = simpleOps[node.left.value](a, simpleOps[node.value](b, c));

                        if (Math.abs(val1 - val2) < 0.0001) {
                             // Valid!
                             const res = fracOps[node.value](node.left.right.value, node.right.value);
                             return {
                                 ...node.left,
                                 right: { id: 'new-'+Math.random(), type: 'operand', value: res }
                             };
                        }
                    }
                }

                // Recursion
                if (node.type === 'operator') {
                    const l = traverse(node.left);
                    const r = traverse(node.right);
                    if (l !== node.left || r !== node.right) {
                        return { ...node, left: l, right: r };
                    }
                }
                return node;
            };

            const result = traverse(deepClone(fullTree));
            return result === fullTree ? null : result;
        }

        // Check if a node is clickable (Standard OR Smart)
        // We do this by effectively "Dry Running" the transformation
        function checkCanEvaluate(fullTree, nodeId) {
            const map = createRandomValueMap(fullTree);
            const res = validateAndExecute(fullTree, nodeId, map, 0);
            return res !== null;
        }


        // --- UI Rendering ---

        function formatFractionText(f) { return f.d === 1 ? f.n.toString() : `${f.n}/${f.d}`; }
        
        function getPrecedence(op) {
            if (op === '×' || op === '÷') return 2;
            if (op === '+' || op === '-') return 1;
            return 0;
        }

        function getExpressionNodes(node) {
            if (node.type === 'operand') return [{ type: 'operand', source: node }];
            const currentPrec = getPrecedence(node.value);
            let leftNodes = getExpressionNodes(node.left);
            let rightNodes = getExpressionNodes(node.right);
            if (node.left.type === 'operator') {
                if (getPrecedence(node.left.value) < currentPrec) {
                    leftNodes = [{type: 'bracket', value
